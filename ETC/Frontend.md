### 브라우저의 렌더링

1. 브라우저는 HTML, CSS, 자바스크립트 등 렌더링에 필요한 리소스를 요청하고, 서버로부터 응답을 받는다.
2. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 DOM과 CSSOM을 생성하고, 이들을 결합하여 렌더 트리를 생성한다.
3. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST(Abstract Syntax Tree)를 생성하고, 바이트코드로 변환하여 실행한다.
4. 렌더 트리를 기반으로 HTML 요소의 레이아웃을 계산하고 브라우저 화면에 HTML 요소를 페인팅한다.



### Http와 Https 통신 방식의 차이

HTTP (HyperText Transfer Protocol) : 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜이다. 인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약으로, 80번 포트를 사용하고 있다.

HTTPS (HyperText Transfer Protocol Secure) : HTTP에 데이터 암호화가 추가된 프로토콜이다. 

둘의 가장 큰 차이는 보안이다.



### OOP

Object Oriented Programming

- 상속성 : 상위 클래스로부터 메소드, 변수 등을 하위 클래스가 받아서 사용하는 것이다.
- 다형성 : 하나의 객체가 여러 가지 타입을 가질 수 있는 것이다.
- 캡슐화 : 외부에서 쉽게 데이터를 접근할 수 없게 하는 것이다.
- 추상화 : 공통적인 속성이나 기능을 묶어서 이름을 붙이는 것이다.



### ES6

Babel을 사용하면 ES6 지원 부족을 어느정도 해결할 수 있다. ES6 문법의 코드들을 브라우저가 이해할 수 있도록 ES5 이하의 문법으로 변환한다.

**Babel** : 트랜스파일러로, 한 언어로 작성된 소스코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환하는 것이다. Babel은 JavaScript로 변환한다.

**ES6 추가된 스펙** : let, const, 화살표 함수, 클래스, 프로미스, 스프레드 연산자



### TypeScript

TypeScript는 동적타입언어인 JavaScript를 보완하기 위해서 타입을 지정해주는 정적타입언어이다. 코드 작성 단계에서 오류를 확인할 수 있고, 미리 타입을 결정하기 때문에 실행 속도가 빠르다는 장점이 있다. 하지만 코드 작성 시 매번 타입을 정해야 하기 때문에 번거롭고, 코드량이 증가한다는 단점이 있다.



### Interface

TypeScript에서는 Object(객체) 타입을 선언할 때, interface와 type을 사용한다. 사용하지 않는다면 객체의 속성에 접근할 때 에러가 발생한다.

인터페이스는 다음과 같은 범주에 대해 정의할 수 있다.

- 객체의 속성과 속성의 타입
- 함수의 파라미터
- 함수의 파라미터, 반환 타입
- 배열과 객체를 접근하는 방식
- 클래스

```typescript
enum Gender {
    Man,
    Woman
}

interface User {
    name: string;
    age: number;
    gender?: Gender       // 옵셔널
}

const user:User = {
    name: "seulgi",
    age: 28,
    gender: Gender.Woman
}
```



### Angular와 React

Angular는 프레임워크, React는 라이브러리이다. Angular는 양방향 바인딩 개념으로, Model과 View가 연결되어 있어서 데이터 값이 한쪽에서 변화하면 다른 쪽에서도 바로 업데이트된다. React는 Virtual DOM을 가지고 있다. 가상 DOM이 있기 때문에 상태를 비교하여 부분적으로 랜더링 할 수 있어서 속도가 빠르다.



### 라이브러리와 프레임워크

프레임워크 : 뼈대나, 기반구조를 의미하며 '소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합'이라 할 수 있다. 

- 특정 개념들의 추상화를 제공하는 여러 클래스나 컴포넌트로 구성
- 컴포넌트 재사용 가능
- 높은 수준에서 패턴들 조작화

라이브러리 : 단순 활용가능한 도구들의 집합. 개발자가 만든 클래스에서 호출하여 사용되고, 클래스들의 나열로 필요한 클래스를 불러와서 사용한다.

프레임워크와 라이브러리 차이는 '제어 흐름에 대한 주도성이 누구에게 있는가'에 있다. 프레임워크는 전체적인 흐름을 스스로가 갖고 있으며 사용자는 그 안에서 필요한 코드를 짜는 것이다. 반면 라이브러리는 사용자가 전체적인 흐름을 만들며 라이브러리를 주도적으로 쓸 수 있다.



### 메소드 체이닝

OOP에서 여러 메소드를 이어서 호출하는 문법이다. 메소드가 객체를 반환하여 여러 메소드를 순차적으로 선언할 수 있도록 한다. 메소드 체이닝을 이용하면 코드가 간결해진다는 장점이 있다.



### Eslint

Eslint는 소스코드를 스캔하여 문법적 오류나 잠재적 오류까지 찾아내고, 오류 원인을 볼 수 있도록 해주는 도구이다.



### Prettier

Prettier는 정해진 규칙대로 코드를 조정해주는 도구이다. 들여쓰기, 따옴표 등



### Webpack

웹팩은 오픈 소스 자바스크립트 모듈 번들러이다. 웹팩은 의존성이 있는 모듈을 취하여 해당 모듈을 대표하는 정적 자산들을 생성한다. (하나의 파일로 실행시켜주는 것)



### package.json

프로젝트의 정보를 정의하고, 의존하는 패키지 버전 정보를 명시하는 파일이다. 일반적으로 루트 디렉토리에 위치하며 프로젝트 정보, 패키지 정보로 나눌 수 있다.

- 프로젝트 정보 : name, version

- 패키지 정보 : dependencies 또는 devDependencies

  > dependencies : 프로덕션 환경에서 응용 프로그램에 필요한 패키지
  >
  > devDependencies : 로컬 개발 및 테스트에 필요한 패키지



### 패키지와 모듈

패키지 : package.json으로 설명되는 파일 또는 디렉토리

모듈 : node.js의 require( ) 함수로 로드될 수 있는 node_modules 디렉토리안의 파일 디렉토리



### 프로세스와 스레드

프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고, 스레드는 프로세스가 할당받은 자원을 이용하는 실행 단위이다.



### 이벤트 위임

자식 요소의 이벤트를 부모 요소에서 감지할 수 있으나 이벤트를 하나하나 등록하는 것이 아니라 부모에게 이벤트를 위임하는 방법이다.



### Vue와 React

공통점은 둘 다 컴포넌트를 기반으로 한다는 것이다. 차이점은 React는 라이브러리이며 Vue는 프레임워크라는 점이다. 라이브러리는 일부분만 가져와서 사용할 수 있기 때문에 자유도가 매우 높다. 반면 Vue는 프레임워크이기 때문에 부분적인 사용이 불가능하고 프레임워크 안으로 들어가서 프레임워크가 지원해주는 문법에 따라 작성해야 한다.

코드 형태 차이 : 리액트는 JSX (JavaScript XML) 형태로 코드를 작성하여 JavaScript 문법을 응용하기 때문에 JavaScript 만으로 UI 로직과 DOM을 구현한다. 하지만 Vue는 HTML, JS, CSS 코드 영역을 분리해서 작성한다. 



### Vue 라이프사이클

creation, mounting, updating, destruction으로 나눌 수 있다.

- creation : 컴포넌트들을 초기화하는 단계

  > 서버렌더링에서 지원되는 단계
  >
  > 클라이언트나 서버 렌더 단에서 처리해야할 일이 있으면 이 단계에서 처리

  - beforeCreate : 제일 먼저 실행되는 훅

    > 데이터와 이벤트들이 설정되지 않아서 접근할 수 없음

  - created : 템플릿 및 Virtual DOM이 마운팅 혹은 렌더링 되기 전에 실행

    > 데이터 초기화 시에 사용

- mounting : 초기 렌더링 전후에 즉시 컴포넌트에 액세스할 수 있다. 초기 렌더링 직전이나 직후에 DOM에 접근하거나 수정해야 하는 경우 사용한다. 

  - beforeMount : 함수들이 컴파일 직후, 렌더링 직전에 실행된다.

  - mounted : 컴포넌트, 템플릿, 렌더링된 DOM에 접근할 수 있고 DOM을 수정하기 위해 사용된다.

- updating : 컴포넌트에서 사용하는 반응형 속성들이 변경되거나 리렌더링될 때마다 호출된다.

  - beforeUpdated : DOM이 리렌더링되기 전에 실행된다.
  - updated : 컴포넌트 데이터가 변경되어 DOM이 리렌더링된 후 실행된다.

- Destruction : 컴포넌트가 해체되고 DOM에서 제거될 때 실행된다.

  - beforeDestroy : Vue 인스턴스가 제거되기 전에 실행된다.
  - destroyed : 컴포넌트가 해체된 후 호출된다.



### React 라이프사이클

마운트, 업데이트, 언마운트

- mount : 컴포넌트가 생성될 때 발생하는 생명주기
  - constructor : 컴포넌트가 생성되면 가장 먼저 실행되는 메서드
  - getDerivedStateFromProps : props로부터 파생된 state 가져온다.
  - render : 컴포넌트 렌더링 메서드
  - componentDidMount : 컴포넌트의 첫번째 렌더링이 마치면 호출되는 메서드이다. 이 메서드가 호출되는 시점에는 화면에 컴포넌트가 나타난 상태이다.
- updating : 컴포넌트가 업데이트되는 시점
  - getDerivedStateFromProps : 컴포넌트의 props나 state가 바뀌었을 때도 이 메서드가 호출된다.
  - shouldComponentUpdate : 컴포넌트가 리렌더링할지 말지를 결정하는 메서드이다.
  - componentDidUpdate : 컴포넌트가 업데이트되고 난 후에 발생한다.
- unmount : 컴포넌트가 화면에서 사라지는 것
  - componentWillUnmount : 컴포넌트가 화면에서 사라지기 직전에 호출된다.



### Virtual DOM

실제 DOM 변화를 최소화시켜주는 역할을 한다. 만약 뷰에 변화가 있다면 실제 DOM에 적용되기 전에 Virtual DOM에 변화된 부분만 적용시키고 최종 결과만 DOM에 전달한다.



### 호이스팅

변수를 선언하고 초기화했을 때 선언 부분이 최상단으로 끌어올려지는 것이다.



### 이벤트 버블링

어떤 요소에 대한 이벤트가 발생했을 때, 해당 요소의 최상위 부모까지 이벤트가 전달되어지는 과정이다. HTML 구조상 자식 요소에 발생한 이벤트가 상위 부모 요소에 영향을 미치는 것이다.



### React, Vue, Angular

3개의 공통점은 SPA를 기반으로 한다는 것이다. React는 단방향 바인딩으로 부모 컴포넌트에서 props가 자식 컴포넌트로 전달되고, Vue나 Angular는 양방향 바인딩이 구현 가능하다는 차이가 있다. React는 jsx 문법을 사용하며, 개발 생태계가 가장 잘 활성화 되어있다. Angular는 타입스크립트를 사용함으로써 코드의 가독성과 안정성이 좋다.



### React의 상태관리 방법

context API를 통한 방법, Redux, Recoil 등의 라이브러리를 사용하는 방법이 있다. Redux는 전역 상태를 생성하고 관리하며 가장 많이 사용되는 것이다. 컴포넌트에서 액션 크리에이터를 통해 액션을 만들고, 그 액션을 디스패치 함수로 실행시킨다. 그러면 store에서 해당 리듀서로 매칭되는 액션이 있는지 확인하고, 스토어에 저장된 상태를 변경해주는 원리로 작동한다. 리덕스는 redux-saga, redux-thunk등 추가 라이브러리를 통해 비동기 작업을 쉽게 해줄 수 있다. 리덕스의 장점은 컴포넌트의 상태 관련 로직을 따로 분리시켜 효과적으로 관리할 수 있고, 상태를 공유할 때에도 다른 컴포넌트를 거치지 않고 Store를 통해 전달이 가능해서 편리하다.



### var, let, const

- var : 중복 선언, 재할당 모두 가능하다.
- let : 재할당만 가능하다.
- const : 재할당, 중복 선언 모두 불가능하다.



### MVC, MVVM

- MVC 패턴은 모델, 뷰, 컨트롤러를 합친 것이다. 모델은 데이터를 처리하는 것이고, 뷰는 사용자에게 보여지는 부분이다. 컨트롤러는 사용자의 입력을 받고, 처리하는 부분이다. 
  - 사용자의 Action이 컨트롤러에 들어오면 컨트롤러가 액션을 확인하고, 모델을 업데이트 한다.
  - 컨트롤러는 모델을 나타내줄 View를 선택하고, View는 모델을 이용하여 화면을 나타낸다.
- MVVM 패턴은 모델, 뷰, 뷰모델을 합친 것이다. 뷰모델은 뷰를 표현하기 위해 만들어진 뷰를 위한 모델이며, 뷰는 사용자가 보여지는 부분이다. 모델은 데이터 및 데이터 조작 부분을 담당한다. 
  - 사용자의 액션이 View를 통해 들어오면 ViewModel에게 Action을 전달한다.
  - ViewModel은 Model에게 데이터를 요청한다.
  - Model은 ViewModel에게 데이터를 응답한다.
  - View는 ViewModel과 데이터 바인딩하여 화면에 나타낸다.



### Flex

아이템이 자신의 컨테이너가 차지하는 공간에 맞추기 위해 크기를 키우거나 줄이는 방법을 설정하는 속성이다.



### useMemo vs useCallback

둘 다 메모이제이션 훅으로 연산 된 값을 자료구조에 저장하고, 재사용 시 계산을 반복하지 않고 바로 꺼내서 사용할 수 있게 해준다. useCallback은 전달된 함수 그 자체를 캐싱하지만 useMemo는 전달된 함수가 실행되고 반환된 결과를 캐싱한다.



### 비동기 함수

현재 실행중인 코드 완료 여부와 무관하게 즉시 다음 코드로 넘어간다.



### Promise

비동기 동작을 다루기 위한 패턴으로, 비동기 요청을 보내면 성공 또는 실패가 다양한 형태로 발생한다. then or catch 구문을 사용한다.



### Async, Await와 Promise

비동기 동작을 다루기 위한 패턴이다. await은 호출되는 함수가 적절한 결과를 반환할 때까지 기다리도록 동작한다. promise를 사용할 때는 .catch() 문으로 에러 핸들링을 할 수 있지만 Async, Await는 에러 핸들링이 없어서 try~catch문을 사용해야 한다.



### JWT

JSON Web Token의 약자로, 데이터가 JSON으로 이루어져 있는 토큰을 의미한다. 사용자 인증에 필요한 정보를 토큰 자체에 담고 있어서 별도 저장소에 정보를 저장해 둘 필요가 없다. 하지만 한번 발급된 토큰은 수정 및 폐기가 불가하다는 단점이 있고, 유효기간을 짧게 지정해줘야 하는 것이 중요하다.



### async/awiat

callback과 Promise보다 좀 더 비동기 작업을 일반적인 함수적으로 실행하기 위해 나온 객체이다. 동기식으로 비동기 코드를 적을 수 있다. 함수 선언자 앞에 async 붙여주고, 비동기가 필요한 작업 앞에 await를 붙여서 결과 값을 기다린다.



### React hooks

리액트 훅은 함수형 컴포넌트에서도 클래스형 컴포넌트의 기능을 사용할 수 있게 하는 것이다. 함수형 컴포넌트에서 상태 값을 관리할 수도, 새로운 커스텀 훅을 만들 수도 있다. (useState, useEffect, useCallback)



### CORS (Cross-origin resource sharing)

도메인 혹은 포트가 다른 서버의 자원을 요청할 때 발생한다. response 헤더에 "Access-Control-Allow-Origin" 를 추가하던가, 서버 쪽에서 처리를 해주면 된다.



### 함수형 컴포넌트

함수형 컴포넌트는 클래스보다 선언하기 좀 더 편리하고, 함수는 한번 실행되면 메모리 상에서 사라지기 때문에 메모리 자원을 덜 사용하는 것이 강점이다. hook을 사용할 수 있고, return문을 사용한다.



### props와 state

props와 state 모두 리액트 컴포넌트에서 다루는 데이터로, props는 부모 컴포넌트에서 받은 데이터이다. 리액트는 부모에서 자식으로만 데이터가 흐르는 단방향 형식으로, props는 수정이 불가능하다. 반면 state는 해당 컴포넌트 내부에서 선언되기 때문에 수정이 가능하다. 



### undeclared

undefined : 접근 가능한 스코프에 변수가 선언되었으나 아무런 값도 할당되지 않은 상태

undeclared : 접근 가능한 스코프에 변수 선언조차 되어있지 않은 상태

Null : 변수를 선언하고, null 값 할당한 경우



### forEach와 Map

반복문. forEach는 배열의 각 요소에 콜백함수를 실행하고, map은 새로운 배열을 반환한다.



### "=="와 "==="

"=="는 동등 연산자로, 비교하는 대상의 타입이 다르더라도 비교한다. 두 값의 타입이 다르더라도 값이 같다면 true를 리턴한다. "==="는 일치 연산자로 타입과 값이 모두 같을 경우에만 true를 리턴한다.



### 깊은 복사와 얇은 복사

얇은 복사는 바로 아래 단계의 값만 복사하는 방법이다. 즉 객체를 복사할 때 원래 값과 복사된 값이 같은 참조를 가리키고 있다. 깊은 복사는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법이다.



### NPM과 NPX

Node Package Manager. Node.js로 만들어진 모듈을 웹에서 받아서 설치하고, 관리해주는 프로그램이다. Node.js에서 사용할 수 있는 모듈들을 패키지화에서 모아둔 저장소 역할이며 설치, 관리를 수행할 수 있는 CLI를 제공한다.

Node Package execut. 노드 패키지 실행이라는 의미로, npm 사용 시에 발생하는 문제점을 해결하기 위해 설계되었다.



### this

JavaScript의 예약어로, 자신이 속한 객체 또는 생성할 인스턴스를 가리키는 자기 참조 변수이다.



### 콜백함수

다른 함수의 인자로써 이용되는 함수이며 제어권도 함께 위임한 함수이다. 혹은 어떤 이벤트에 의해 호출되어지는 함수라고도 한다.

```javascript
function func(callback) {
	callback();
}
function callback() {
	console.log("callback이다");
}

func(callback);
```



### Map()과 Set()

Map은 Key가 있는 데이터를 저장한다. 객체와 비슷한 면이 있지만 키에 다양한 자료형을 허용한다. Set은 중복을 허용하지 않는 값을 모아놓은 객체이다.



### TDD (Test-Driven Development)

테스트 주도 개발이라는 뜻으로, 먼저 테스트 코드를 작성한 후에 구현을 하는 방식이다.



### useEffect

컴포넌트가 렌더링되거나 업데이트 될 때 그 안에 있는 기능을 실행할 수 있는 React Hooks 중 하나이다. 두 번째 파라미터의 배열에 값을 넣어주면 그 값이 업데이트 될 때 마다 스코프 안에 있는 코드가 실행된다.



### useState

함수형 컴포넌트에서 상태값을 관리하게 해주는 것이다. initialState를 파라미터로 받고, state와 state를 변경할 setState 함수를 반환한다.



### import와 require

import와 require 모두 외부 라이브러리나 다른 파일을 불러오는 동일한 목적이 있다. import는 바로 키워드를 사용하여 모듈을 불러올 수 있지만 require는 다른 변수를 할당하듯이 불러와야 한다.



### POST와 GET

GET은 서버로부터 정보를 조회하기 위한 메소드이고, POST는 리소스를 생성/변경하기 위한 메소드이다. POST는 서버로 데이터를 전송할 때 body에 포함시킬 수 있지만 GET은 필요한 데이터를 URL에 포함하여 요청하여야 한다.

